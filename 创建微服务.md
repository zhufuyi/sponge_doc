
建议创建rpc服务时候使用**ui界面**方式，其他使用**命令行**方式，这样可以节省复制代码操作。当然可以只使用**ui界面**方式生成代码，也可以只用**命令行**方式生成代码，下面使用**命令行**方式介绍。

### 根据sql创建rpc服务

**根据sql创建rpc服务**的意思是在创建rpc服务工程项目中，顺便生成数据表的CRUD逻辑代码和对应protobuf，使得生成的rpc服务代码编译运行就有rpc方法使用，当然后面新添加数据表可以继续生成新的rpc方法代码。

#### 生成rpc服务代码

以 **章节3.1.1** 的teacher表为例，创建rpc服务：

```bash
sponge micro rpc \
  --module-name=edusys \
  --server-name=edusys \
  --project-name=edusys \
  --repo-addr=zhufuyi \
  --db-dsn=root:123456@(192.168.3.37:3306)/school \
  --db-table=teacher \
  --out=./edusys
```

查看参数说明命令 `sponge micro rpc -h`，生成rpc服务代码在当前edusys目录下，目录结构如下：

```
.
├── api
│    ├── edusys
│    │    └── v1
│    └── types
├── build
├── cmd
│    └── edusys
│          └── initial
├── configs
├── deployments
│    ├── docker-compose
│    └── kubernetes
├── docs
├── internal
│    ├── cache
│    ├── config
│    ├── dao
│    ├── ecode
│    ├── model
│    ├── server
│    └── service
├── scripts
└── third_party
```

在edusys目录下的Makefile文件，集成了编译、测试、运行、部署等相关命令，切换到edusys目录下执行命令运行服务：

```bash
# 生成*pb.go
make proto

# 编译和运行服务
make run
```

rpc服务包括了CRUD逻辑代码，也包括rpc客户端测试和压测代码，使用**Goland**或**VS Code**打开`internal/service/teacher_client_test.go`文件，

- 对 **Test_teacherService_methods** 下的方法测试，测试前要先填写测试参数。
- 执 **Test_teacherService_benchmark** 下的方法压测，测试前要先填写压测参数，执行结束后生成压测报告，复制压测报告文件路径到浏览器查看统计信息，如图4-1所示。

![performance-test](https://raw.githubusercontent.com/zhufuyi/sponge_doc/main/assets/img/performance-test.jpg)
*图4-1 性能测试报告界面*

<br>

从服务启动日志看到默认监听**8282**端口(rpc服务)和**8283**端口(采集metrics或profile)，开启了每分钟的打印资源统计信息。在实际应用中，根据需要做一些修改：

- 使用redis作为缓存，打开配置文件`configs/edusys.yml`，把**cacheType**字段值改为redis，并且填写**redis**配置地址和端口。
- 默认限流、熔断、链路跟踪、服务注册与发现功能是关闭的，可以打开配置文件`configs/edusys.yml`开启相关功能，如果开启链路跟踪功能，需要填写jaeger配置信息，如果开启服务注册与发现功能，需要填写consul、etcd、nacos其中一种配置信息。
- 如果增加或修改了配置字段名称，执行命令 `sponge config --server-dir=./edusys` 更新对应的go struct，只修改字段值不需要执行更新命令。
- 修改CRUD方法对应的错误码和错误信息，打开`ingernal/ecode/teacher_rpc.go`，修改变量**teacherNO**值(数值唯一)，返回信息说明根据自己需要修改，对teacher表操作的接口错误信息都在这里添加。

<br>

#### 生成service代码

service代码由protobuf代码、model代码、dao代码、CRUD逻辑代码、测试代码、错误码等组成，把service代码直接复制到rpc服务代码文件夹，表示新添加对数据表的增删改查方法。

根据业务需求，添加了两个新表course和teach，数据表的结构看 **章节3.1.3**，生成service代码到指定的rpc服务(这里是edusys)目录中，表示edusys服务添加了对两个表的CRUD逻辑代码：

```bash
sponge micro service \
  --db-dsn=root:123456@(192.168.3.37:3306)/school \
  --db-table=course,teach \
  --out=./edusys
```

查看参数说明命令 `sponge micro service -h`，参数`out`指定已存在的rpc服务文件夹edusys，如果参数`out`为空，必须指定`module-name`和`server-name`两个参数，在当前目录下生成service代码，然后手动复制到文件夹edusys，两种方式效果都一样。

执行命令后，在下面目录下生成了course和teach相关的代码，如果添加自定义方法或新的protocol buffers文件，也是在下面目录手动添加代码。

```
.
├── api
│    └── edusys
│          └── v1
└── internal
      ├── cache
      ├── dao
      ├── ecode
      ├── model
      └── service
```

<br>

切换到edusys目录下执行命令运行服务：

```bash
# 更新*.pb.go
make proto

# 编译和运行服务
make run
```

使用**Goland**或**VS Code**打开`internal/service/course_client_test.go`和`internal/service/teach_client_test.go`文件测试CRUD方法，测试前需要先填写参数。

<br>

### 根据proto文件创建rpc服务

根据sql生成的rpc服务(只有增删改查方法)，满足不了实际业务需求(例如user服务的注册、登录、登出方法)，更通用生成rpc服务代码方式是在proto填写自定义方法，然后根据proto创建rpc服务和生成模板代码。

**根据proto文件创建rpc服务**的意思是在创建rpc服务项目中，顺便生成proto对应的模板代码，使得生成的rpc服务代码编译运行就有rpc方法使用，当然后面添加新proto文件可以继续生成新的rpc方法。

#### 自定义方法

下面是一个proto示例文件 teacher.proto 内容：

```protobuf
syntax = "proto3";

package api.edusys.v1;
option go_package = "edusys/api/edusys/v1;v1";

service teacher {
  rpc Register(RegisterRequest) returns (RegisterReply) {}
  rpc Login(LoginRequest) returns (LoginReply) {}
}

message RegisterRequest {
  string name = 1;
  string email = 2;
  string password = 3;
}

message RegisterReply {
  int64   id = 1;
}

message LoginRequest {
  string email = 1;
  string password = 2;
}

message LoginReply {
  string token = 1;
}
```

<br>

#### 生成rpc服务代码

打开终端，执行命令：

```bash
sponge micro rpc-pb \
  --module-name=edusys \
  --server-name=edusys \
  --project-name=edusys \
  --repo-addr=zhufuyi \
  --protobuf-file=./teacher.proto \
  --out=./edusys
```

查看参数说明命令`sponge micro rpc-pb -h`，支持\*号匹配(示例`--protobuf-file=*.proto`)，表示根据批量proto文件生成代码，多个proto文件中至少包括一个service，否则无法生成代码。

生成rpc服务代码目录如下所示，与`sponge micro rpc`生成的rpc服务代码目录有一些区别，internal目录下没有**cache**、**dao**、**model**子目录。

```
.
├── api
│    └── edusys
│          └── v1
├── build
├── cmd
│    └── edusys
│          └── initial
├── configs
├── deployments
│    ├── docker-compose
│    └── kubernetes
├── docs
├── internal
│    ├── config
│    ├── ecode
│    ├── server
│    └── service
├── scripts
└── third_party
```

切换到edusys目录下执行命令运行服务：

```bash
# 生成*pb.go文件、生成service模板代码
make proto

# 编译和运行服务
make run
```

启动rpc服务之后，使用**Goland**或**VS Code**打开`internal/service/teacher_client_test.go`文件，对 **Test_teacher_methods** 下各个方法进行测试，测试前要先填写测试参，会发现请求返回内部错误，因为在模板代码文件`internal/service/teacher.go`插入了代码`panic("implement me")`，这是为了提示要填写业务逻辑代码。

<br>

#### 添加新的rpc方法

根据业务需求，需要添加新方法，分为两种情况操作：

**(1) 在原来proto文件添加新方法**

打开 `api/edusys/v1/teacher.proto`，例如添加**bindPhone**方法。

执行命令：

```bash
# 生成*pb.go文件、生成service模板代码
make proto
```

在 `internal/service`和`internal/ecode` 两个目录下生成模板代码，然后复制模板代码到业务逻辑代码区：

- 在`internal/service`目录下生成了后缀为 **.gen.日期时间** 模板代码文件(示例teacher.go.gen.xxxx225732)，因为teacher.go已经存在，不会把原来写的业务逻辑代码覆盖，所以生成了新的文件，打开文件 teacher.go.gen.xxxx225732，把添加**bindPhone**方法的模板代码复制到teacher.go文件中，然后填写业务逻辑代码。
- 在`internal/ecode`目录下生成了后缀为 **teacher_rpc.go.gen.日期时间** 文件，把**bindPhone**方法对应的错误码复制到teacher_rpc.go文件中。
- 删除所有后缀名为 **.gen.日期时间** 文件。

<br>

**(2) 在新的proto文件添加新方法**

例如新添加了**course.proto**文件，把**course.proto**文件复制到`api/edusys/v1`目录下，完成新添加接口。

执行命令：

```bash
# 生成*pb.go文件、生成service模板代码
make proto
```

在 `internal/service`、`internal/ecode`、 `internal/routers` 三个目录下生成**course**名称前缀的代码文件，只需做下面两个操作：

- 在`internal/service/course.go`文件填写业务代码。
- 在`internal/ecode/course_rpc.go`文件修改自定义错误码和信息说明。

<br>

#### 完善rpc服务代码

把自定义接口描述信息写proto文件，根据proto生成的api只有模板代码，业务逻辑还没实现，因此没有`dao`、`cache`、`model`模块代码，需要使用者自己去实现，当然sponge也提供了生成`dao`、`cache`、`model`代码命令，如果当前项目刚好是使用mysql数据库和redis缓存，可以使用**sponge web dao命令**工具直接生成`dao`、`cache`、`model`代码，然后在代码模板上引用即可。

生成CRUD操作数据库代码命令：

```bash
sponge micro dao \
  --db-dsn=root:123456@(192.168.3.37:3306)/school \
  --db-table=teacher \
  --include-init-db=true \
  --out=./edusys
```

查看参数说明命令`sponge micro dao -h`，参数`--include-init-db`在一个服务中只使用一次，下一次生成`dao`代码时去掉参数`--include-init-db`，否则会造成无法生成最新的`dao`代码，

使用sponge生成的`dao`代码，需要做一些操作：

- 在服务的初始化和释放资源代码中加入mysql和redis，打开`cmd/edusys/initial/initApp.go`文件，把调用mysql和redis初始化代码反注释掉，打开`cmd/edusys/initial/registerClose.go`文件，把调用mysql和redis释放资源代码反注释掉，初始代码是一次性更改。
- 生成的`dao`代码，并不能和自定义方法**register**和**login**完全对应，需要手动在文件`internal/dao/teacher.go`补充代码，然后在`internal/handler/teacher.go`填写业务逻辑代码，业务代码中返回错误使用`internal/ecode`目录下定义的错误码，如果直接返回错误信息，请求端会收到unknown错误信息，也就是未定义错误信息。
- 默认使用了本地内存做缓存，改为使用redis作为缓存，在配置文件`configs/edusys.yml`修改字段**cacheType**值为redis，并填写redis地址和端口。

切换到edusys目录下再次运行服务：

```bash
go mod tidy

# 编译和运行服务
make run
```

启动rpc服务之后，使用**Goland**或**VS Code**打开`internal/service/teacher_client_test.go`文件测试各个方法。

<br>

### 根据proto文件创建rpc gateway服务

微服务通常提供的是细粒度的API，实际提供给客户端是粗粒度的API，需要从不同微服务获取数据聚合在一起组成符合实际需求的API，rpc gateway本身是一个web服务，把rpc方法转为http请求。常见rpc gateway所在服务位置如图4-2所示。

![rpc-gateway](https://raw.githubusercontent.com/zhufuyi/sponge_doc/main/assets/img/rpc-gateway.png)
*图4-2 rpc gateway所在服务位置*

<br>

#### 定义protocol buffers

以电商微服务为例，商品详情页面有商品、库存、商品评价等信息，这些信息保存在不同的微服务中，一般很少请求每个微服务获取数据，直接请求微服务会造成网络压力倍增，通常的做法是聚合多个微服务数据一次性返回。

下面四个文件夹，每个文件夹下都有一个简单的proto文件。

- **comment**: 评论服务的proto目录
- **inventory**: 库存服务的proto目录
- **product**: 产品服务的proto目录
- **shopgw**: rpc网关服务的proto目录

```
.
├── comment
│    └── v1
│          └──comment.proto
├── inventory
│    └── v1
│          └── inventory.proto
├── product
│    └── v1
│          └── product.proto
└── shopgw
      └── v1
            └── shopgw.proto
```

**comment.proto**文件内容如下：

```protobuf
syntax = "proto3";

package api.comment.v1;

option go_package = "shopgw/api/comment/v1;v1";

service Comment {
  rpc ListByProductID(ListByProductIDRequest) returns (ListByProductIDReply) {}
}

message ListByProductIDRequest {
  int64 productID = 1;
}

message CommentDetail {
  int64  id=1;
  string username = 2;
  string content = 3;
}

message ListByProductIDReply {
  int32 total = 1;
  int64 productID = 2;
  repeated CommentDetail commentDetails = 3;
}
```

<br>

**inventory.proto**文件内容如下：

```protobuf
syntax = "proto3";

package api.inventory.v1;

option go_package = "shopgw/api/inventory/v1;v1";

service Inventory {
  rpc GetByID(GetByIDRequest) returns (GetByIDReply) {}
}

message GetByIDRequest {
  int64 id = 1;
}

message InventoryDetail {
  int64 id = 1;
  float num = 4;
  int32 soldNum =3;
}

message GetByIDReply {
  InventoryDetail inventoryDetail = 1;
}
```

<br>

**product.proto**文件内容如下：

```protobuf
syntax = "proto3";

package api.product.v1;

option go_package = "shopgw/api/product/v1;v1";

service Product {
  rpc GetByID(GetByIDRequest) returns (GetByIDReply) {}
}

message GetByIDRequest {
  int64 id = 1;
}

message ProductDetail {
  int64 id = 1;
  string name = 2;
  float price = 3;
  string description = 4;
}

message GetByIDReply {
  ProductDetail productDetail = 1;
  int64 inventoryID = 2;
}
```

<br>

**shopgw.proto**文件内容如下，rpc网关服务的proto和其他rpc服务的proto有一点区别，需要指定方法的路由和swagger的描述信息。

```protobuf
syntax = "proto3";

package api.shopgw.v1;

import "api/product/v1/product.proto";
import "api/comment/v1/comment.proto";
import "api/inventory/v1/inventory.proto";
import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option go_package = "shopgw/api/shopgw/v1;v1";

// default settings for generating *.swagger.json documents
option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  host: "localhost:8080"
  base_path: ""
  info: {
    title: "eshop api docs";
    version: "v0.0.0";
  };
  schemes: HTTP;
  schemes: HTTPS;
  consumes: "application/json";
  produces: "application/json";
};

service ShopGw {
  rpc GetDetailsByProductID(GetDetailsByProductIDRequest) returns (GetDetailsByProductIDReply) {
    option (google.api.http) = {
      get: "/api/v1/detail"
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      summary: "get detail",
      description: "get detail from product id",
      tags: "shopgw",
    };
  }
}

message GetDetailsByProductIDRequest {
  int64 productID = 1;
}

message GetDetailsByProductIDReply {
  api.product.v1.ProductDetail productDetail = 1;
  api.inventory.v1.InventoryDetail inventoryDetail = 2;
  repeated api.comment.v1.CommentDetail commentDetails = 3;
}
```

<br>

#### 生成rpc gateway服务代码

根据**shopgw.proto**文件生成rpc gateway服务代码：

```bash
sponge micro rpc-gw-pb \
  --module-name=shopgw \
  --server-name=shopgw \
  --project-name=eshop \
  --repo-addr=zhufuyi \
  --protobuf-file=./shopgw/v1/shopgw.proto \
  --out=./shopgw
```

查看参数说明命令 `sponge micro rpc-gw-pb -h`，生成的rpc gateway服务代码在当前shopgw目录下，目录结构如下：

```
.
├── api
│    └── shopgw
│          └── v1
├── build
├── cmd
│    └── shopgw
│          └── initial
├── configs
├── deployments
│    ├── docker-compose
│    └── kubernetes
├── docs
├── internal
│    ├── config
│    ├── ecode
│    ├── routers
│    ├── rpcclient
│    └── server
├── scripts
└── third_party
```

因为**product.proto**依赖**product.proto**、**inventory.proto**、**comment.proto**文件，复制三个依赖的proto文件到api目录下，api目录结构如下：

```
.
├── comment
│    └── v1
│          └── comment.proto
├── inventory
│    └── v1
│          └── inventory.proto
├── product
│    └── v1
│          └── product.proto
└── shopgw
      └── v1
            └── shopgw.proto
```

<br>

切换到shopgw目录下运行服务：

```bash
# 生成*pb.go文件、生成模板代码、更新swagger文档
make proto

# 编译和运行服务
make run
```

复制 http://localhost:8080/apis/swagger/index.html 到浏览器测试接口，如图4-3所示。请求会返回500错误，因为模板代码(internal/service/shopgw_logic.go文件)直接调用`panic("implement me")`，这是为了提示要填写业务逻辑代码。

![rpc-gw-swag](https://raw.githubusercontent.com/zhufuyi/sponge_doc/main/assets/img/rpc-gw-swag.jpg)
*图4-3 rpc gateway的swagger文档界面*

<br>

#### 完善rpc gateway服务代码

**(1) 生成连接rpc服务端代码**

服务还没有连接rpc服务代码，下面是生成连接**product**、**inventory**、**comment**三个rpc服务的客户端代码命令：

```bash
sponge micro rpc-cli \
  --rpc-server-name=comment,inventory,product \
  --out=./shopgw
```

查看参数说明命令 `sponge micro rpc-cli -h`，参数`out`指定已存在的服务文件夹shopgw，生成的代码在`internal/rpcclent`目录下。

<br>

**(2) 初始化和关闭rpc连接**

连接rpc服务端代码包括了初始化和关闭函数，根据调用模板代码填写：

- 启动服务时候初始化，在`cmd/shopgw/initial/initApp.go`文件的代码段`// initializing the rpc server connection`下，根据模板调用初始化函数。
- 在关闭服务时候释放资源，在`cmd/shopgw/initial/registerClose.go`文件的代码段`// close the rpc client connection`下，根据模板调用释放资源函数。

<br>

**(3) 修改配置**

连接**product**、**inventory**、**comment**三个rpc服务代码已经有了，但rpc服务地址还没配置，需要在配置文件`configs/shopgw.yml`的字段`grpcClient`下添加连接**product**、**inventory**、**comment**三个rpc服务配置信息：

```yaml
grpcClient:
  - name: "product"
    host: "127.0.0.1"
    port: 8201
    registryDiscoveryType: ""
  - name: "inventory"
    host: "127.0.0.1"
    port: 8202
    registryDiscoveryType: ""   
  - name: "comment"
    host: "127.0.0.1"
    port: 8203
    registryDiscoveryType: ""
```

如果rpc服务使用了注册与发现，字段`registryDiscoveryType`填写服务注册发现类型，支持consul、etcd、nacos三种。

生成对应go struct代码：

```bash
sponge config --server-dir=./shopgw
```

<br>

**(4) 填写业务代码**

下面是在模板文件`internal/service/shopgw_logic.go`填写的业务逻辑代码示例，分别从**product**、**inventory**、**comment**三个rpc服务获取数据聚合在一起返回。

```go
package service

import (
	"context"

	commentV1 "shopgw/api/comment/v1"
	inventoryV1 "shopgw/api/inventory/v1"
	productV1 "shopgw/api/product/v1"
	shopgwV1 "shopgw/api/shopgw/v1"
	"shopgw/internal/rpcclient"
)

var _ shopgwV1.ShopGwLogicer = (*shopGwClient)(nil)

type shopGwClient struct {
	productCli   productV1.ProductClient
	inventoryCli inventoryV1.InventoryClient
	commentCli   commentV1.CommentClient
}

// NewShopGwClient creating rpc clients
func NewShopGwClient() shopgwV1.ShopGwLogicer {
	return &shopGwClient{
		productCli:   productV1.NewProductClient(rpcclient.GetProductRPCConn()),
		inventoryCli: inventoryV1.NewInventoryClient(rpcclient.GetInventoryRPCConn()),
		commentCli:   commentV1.NewCommentClient(rpcclient.GetCommentRPCConn()),
	}
}

func (c *shopGwClient) GetDetailsByProductID(ctx context.Context, req *shopgwV1.GetDetailsByProductIDRequest) (*shopgwV1.GetDetailsByProductIDReply, error) {
	productRep, err := c.productCli.GetByID(ctx, &productV1.GetByIDRequest{
		Id: req.ProductID,
	})
	if err != nil {
		return nil, err
	}

	inventoryRep, err := c.inventoryCli.GetByID(ctx, &inventoryV1.GetByIDRequest{
		Id: productRep.InventoryID,
	})
	if err != nil {
		return nil, err
	}

	commentRep, err := c.commentCli.ListByProductID(ctx, &commentV1.ListByProductIDRequest{
		ProductID: req.ProductID,
	})
	if err != nil {
		return nil, err
	}

	return &shopgwV1.GetDetailsByProductIDReply{
		ProductDetail:   productRep.ProductDetail,
		InventoryDetail: inventoryRep.InventoryDetail,
		CommentDetails:  commentRep.CommentDetails,
	}, nil
}
```

再次启动服务：

```bash
go mod tidy

# 编译和运行服务
make run
```

在浏览器访问 http://localhost:8080/apis/swagger/index.html ，请求返回503错误(服务不可用)，原因是**product**、**inventory**、**comment**三个rpc服务都还没运行。

**product**、**inventory**、**comment**三个rpc服务代码都还没有，如何正常启动呢。这三个rpc服务的proto文件已经有了，参考 **章节 4.2 根据proto文件创建rpc服务** 步骤生成代码和启动服务就很简单了。

<br>

### 总结

生成rpc服务代码是基于sql和proto文件两种方式，根据proto文件方式除了支持生成rpc服务代码，还支持生成rpc gateway服务(http)代码：

- 根据sql生成的rpc服务代码包括每个数据表的CRUD方法逻辑代码和proto代码，后续如果要添加新方法，只需在proto文件定义，手动添加业务逻辑代码可以参考CRUD逻辑代码。
- 根据proto文件生成rpc服务代码不包括操作数据库代码，但可以使用`sponge web dao`命令生成操作数据库代码，根据proto文件生成service模板代码，在模板代码填充业务逻辑代码。
- 根据proto文件生成rpc gateway服务代码，接口定义在proto文件，根据proto文件生成service模板代码，在模板代码填充业务逻辑代码，结合`sponge micro rpc-cli`命令使用。

根据实际场景选择生成对应服务代码，如果主要是对数据表增删改查，根据sql生成rpc服务可以少写代码；如果更多的是自定义方法，根据proto生成rpc服务更合适；rpc转http使用rpc gateway服务。
